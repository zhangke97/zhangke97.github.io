<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[C/C++ Mac上的五子棋🤔]]></title>
      <url>%2F2017%2F08%2F12%2F%E4%BA%94%E5%AD%90%E6%A3%8B%2F</url>
      <content type="text"><![CDATA[本文部分（其实是绝大部分）代码来自 邓昭宇 : 如何用C语言做一个五子棋（Linux）已私信征得作者本人同意 ​ 他们说初学C的都要写过五子棋或者贪吃蛇才算过关，说来惭愧，接触C都一年了也没有写过完整像样的东西（至少c没有）。逛知乎的时候看到了这个五子棋，便试着打了下来。Linux到macOS改动不是很多。。虽然也费了点劲，还是因为自己积累不够吧。 ​ Talk is cheap. ​ 首先是头文件、宏定义以及相应的函数声明 1234567891011121314#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;termios.h&gt;#define CHESS 5 //棋子数#define CELLSLEN 16 //除去边界的空格数#define BOARD (CELLSLEN*2+1) //边界长度void envir(); //初始化棋盘构建void print(); //棋盘显示int Icon(); //光标移动和摆放棋子int checkchess(); //检查一方是否胜利int getch(); //终端的键盘操作 ​ 关于 termios.h 库，原代码是#include&lt;termio.h&gt;，而在Xcode上无限报错，我也没有能力分辨两者的区别，但至少在Xcode这里加上 s 是没有问题的。 ​ CELLSLEN直接影响棋盘大小，根据个人调整，我更喜欢16 x 16 的棋盘。 1234567891011121314const char* board[BOARD][BOARD] = &#123;0&#125;;//相应位置的棋子int check[CELLSLEN][CELLSLEN] = &#123;0&#125;; //检测该位置是否有棋子int turn = -1; // -1 = white, 1 = black , 白棋先走int row = 1, col = 1, con;const char * BLACK = "◎", * WHITE = "◉", * POS = "¤";//¤ 定位光标const char * LT ="┌", * TOP ="┬", * RT ="┐";const char * LEFT ="├", * CENTER="┼", * RIGHT="┤";const char * LF ="└", * FOOT ="┴", * RF ="┘";const char * SPACE=" "; ​ 以上代码声明了两个数组，board用来确定棋盘上的某个点，而check检测该位置的内容。 ​ 这里出现了一个turn的数字，希望记住白棋对应的 turn 是 -1 ，而黑棋是 1，这个在最后判断时会很重要。 ​ 关于棋子的选择，我觉得在gcc的编译里用实心的图案实在是容易眼花（我就这么输给了上小学的弟弟），所以我挑选了◎和◉作为棋子，这只是权宜之策，希望我以后能找到方法改变棋子的颜色吧。 ​ 后面几行应该不难看出来，是在画棋盘的边框和分界线。 ​ 放一张棋盘的图。 ​ 上main函数（千万不要写成mian，不然可能会多花一天的时间） 12345678910111213141516int main(void)&#123; int s; envir(); //构建棋盘 s = Icon(); //运行游戏 if(s)&#123;//由turn的取值决定赢家 if(turn == 1) printf("\n-----White Won-----\n"); else printf("\n-----Black Won-----\n"); &#125; else printf("\n-----Tied-----\n"); return 0;&#125; ​ 函数主体很简单，最后用turn的取值决定赢家，这个取值非常巧妙，在后面的函数里会提到。 ​ ​ 构建和打印棋盘。 12345678910111213141516171819void envir()&#123;//构建棋盘 for(int j = 0; j &lt; BOARD; j++) for(int k = 0; k &lt; BOARD; k++) board[j][k] = SPACE; //棋盘初始化，全部置为空格 board[0][0] = LT; board[0][BOARD-1] = RT; board[BOARD-1][0] = LF; board[BOARD-1][BOARD-1] = RF; for(int i = 2; i &lt; BOARD-2; i+=2)&#123;// +=2 的目的是留有空格 board[0][i] = TOP; board[BOARD-1][i] = FOOT; board[i][0] = LEFT; board[i][BOARD-1] = RIGHT; &#125; for(int j = 2; j &lt; BOARD-2; j+=2) for(int k = 2; k &lt; BOARD-2; k+=2) board[j][k] = CENTER;&#125; ​ 构建棋盘的步骤：先全部置为空格，然后在对应位置填入边框等符号。 12345678910111213void print()&#123; //打印棋盘 system("clear"); //其实只是把之前的内容拉上到看不到的地方 for(int j = 0; j &lt; BOARD; j++)&#123; //列 for(int k = 0; k &lt; BOARD; k++) //行 printf("%s ",board[j][k]); putchar('\n'); &#125; if(turn == 1)//当前的选手及当前位置 printf(" %s Black turn\n",BLACK); else printf(" %s White turn\n",WHITE); printf(" POS(%d,%d)\n",(row+1)/2,(col+1)/2);&#125; ​ 在下面的Icon函数里将会有一个while循环，不断用print()函数刷新棋盘，直到游戏结束。游戏里默认白棋先走，对应的turn为-1，每走一步交换一次turn的值，当游戏因一方胜出而结束时，我们根据turn的值来确定赢家。由于最后一步走完时交换了turn的值，所以要以对应的turn倒过来判断，若turn为 1，则说明上一步为白棋，反之为黑棋。 ​ ​ 还有一个判断函数，判断是否有一方胜利。 123456789101112131415161718192021222324252627282930313233343536373839404142int checkchess()&#123; bool judge; int pres; for(int j = 0; j &lt; CELLSLEN; j++) //按列行检查 for(int k = 0; k &lt; CELLSLEN; k++) if(check[j][k] != 0)&#123; //有棋子，检测 pres = check[j][k]; judge = true; if(j &lt;= CELLSLEN - CHESS &amp;&amp; k &lt;= CELLSLEN - CHESS)&#123; for(int l = 1; l &lt; CHESS ; l++) if(check[j+l][k+l] != pres) //右斜不成功 judge = false; if(judge == true) return 1; &#125; judge = true; if(j &lt;= CELLSLEN - CHESS &amp;&amp; k &gt;= CHESS - 1)&#123; for(int l = 1; l &lt; CHESS; l++) if(check[j+l][k-l] != pres) //左斜不成功 judge = false; if(judge == true) return 1; &#125; judge = true; if(k &lt;= CELLSLEN - CHESS)&#123; for(int l = 1; l &lt; CHESS; l++) if(check[j][k+l] != pres) //垂直不成功 judge = false; if(judge == true) return 1; &#125; judge = true; if(j &lt;= CELLSLEN - CHESS)&#123; for(int l = 1; l &lt; CHESS; l++) if(check[j+l][k] != pres) //水平不成功 judge = false; if(judge == true) return 1; &#125; &#125; return 0;&#125; ​ 返回值为1则有胜利，0则没有。 ​ 最后是游戏主体Icon函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#define NOTCHESS board[row][col] != BLACK &amp;&amp; board[row][col] != WHITEint Icon() //游戏主体&#123; int count = 0; board[row][col] = POS; //坐标点 print(); //先打印一次棋盘 while((con = getch()) != 0x1b) //Esc键，事实证明方向键也可以终止游戏 &#123; if(con == 'w' || con == 's' || con == 'a' || con == 'd' || con == ' ') &#123; //用 w a s d 控制方向 if(con != ' ' &amp;&amp; board[row][col] == POS &amp;&amp; NOTCHESS) board[row][col] = SPACE; switch(con) &#123; case 'w': if(row &gt; 1) row -= 2; if(NOTCHESS) board[row][col] = POS; break; case 's': if(row &lt; BOARD - 2) row += 2; if(NOTCHESS) board[row][col] = POS; break; case 'a': if(col &gt; 1) col -= 2; if(NOTCHESS) board[row][col] = POS; break; case 'd': if(col &lt; BOARD - 2) col += 2; if(NOTCHESS) board[row][col] = POS; break; case ' ':&#123; //落子 if(board[row][col] == BLACK || board[row][col] == WHITE) break; else&#123; if(turn == -1)&#123; //白棋 board[row][col] = WHITE; check[(row-1)/2][(col-1)/2] = -1; &#125; else if(turn == 1)&#123; //黑棋 board[row][col] = BLACK; check[(row-1)/2][(col-1)/2] = 1 ; &#125; turn = -turn; count++; //回合记录 &#125; break; &#125; default : break; &#125; &#125; print(); //不断刷新棋盘 if(count == CELLSLEN * CELLSLEN) //棋盘被占满，游戏结束 return 0; if(checkchess()) //有一方胜利，游戏结束 return 1; &#125; return 0; //这里有改动&#125; ​ 这段代码用了穷举的判断方式，步骤多但全面，其中的很多细节想不清楚非常容易出错，值得注意。 ​ 原代码在最后无return 0的操作，我觉得还是加上为妙。 ​ 关于使用方向键会终止游戏的问题，我会根据原作者的下一篇博客进行修改。 ​ 其实还有一个getch()函数，它本来是conio.h的一个非标准的不回显函数，在Windows上没有问题，但在Mac的Xcode上移植性不是很好，所以和原作者一样，直接构建该函数。 1234567891011121314int getch()&#123; struct termios tm,tm_old; int fd = 0,ch; if(tcgetattr(fd,&amp;tm) &lt; 0) return -1; tm_old = tm; cfmakeraw(&amp;tm); if(tcsetattr(fd,TCSANOW,&amp;tm) &lt; 0) return -1; ch = getchar(); if(tcsetattr(fd,TCSANOW,&amp;tm_old) &lt; 0) return -1; return ch;&#125; ​ 这个函数我并不理解，姑且放之，再等我继续学习吧。 ​ 突然发现，这可能是第一篇关于学习的文章，太惨了，希望以后more and more. ​ ​ 笔芯！！！ ​]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[不否]]></title>
      <url>%2F2017%2F08%2F10%2F%E4%B8%8D%E5%90%A6%2F</url>
      <content type="text"><![CDATA[再见，十八岁和我的姑娘（一） ​ 当看到她手上戴着连线手套的其中一只，另一只正正好好地套在一个男生手上，两只手套用一根长长的毛线相连时，我转头走了。 ​ 这是我第二次偷偷回到南方找她，六个小时的高铁。 我很想要跟她聊一聊，很想她能够回心转意，但是我知道，就到这里了。 ​ 此时距离我们分开，才七天。 ​ 后来我在她的城市里漫无目的地走着，黄兴知道我来，找我喝酒，黄兴说，我早就跟你说了，你俩这距离，不是你就是她，总有一个人要先走。我闷下一杯白酒，我对黄兴说“黄兴，我跟你说，我不是不知道这事的可能性，只是遇到她吧，我什么都想挑战，当年填志愿，是我自己选择离她这么远的，说白了，都是自找的。” 黄兴气愤地声讨她，恨不得用尽唾沫星子把世界上所有负心人的词都放在她身上。其实我能理解黄兴，我俩从小认识，他看着我和她两年的恋爱历程，黄兴这人对感情没那么敏感，他可能理解不了我此时此刻的心痛。我一边灌自己一边平稳他的心情，想让他停止对她的言语攻击。 ​ 我们俩在街头闹到四点，才找到一个地方睡觉。 我睡不着，他如雷贯耳的鼾声一声声地刺激着我的大脑皮层，我每一个身体器官都不住地抽搐，我忍不住爬起来吐了。 反正也是狼狈，大约感觉要把五脏六腑都吐出来以后，我顺便哭了。 ​ 我曾经为我的姑娘哭过两次。一次是她生病，一次是今天。可惜的是，从此以后她都不会有机会知道我今天为她哭过的这一次了。我多希望今天不是哭的时机，多希望把这次哭泣留给未来，留给她答应我求婚的那一刻，留给她为我生下孩子的那一刻，留给我们弥留之际告别的那一刻……她为什么不给我机会，让我把这次哭泣保留下来！ ​ 我们从什么时候开始变了呢？我趴在厕所里问我自己。我盯着天花板的花纹，觉得很晕，身体仿佛飘到了千里之外，意识也开始模糊…… （二） ​ 第一次见到姑娘的时候，我俩都是十七岁，她是我真正意义上的初恋。那时候我很迷冯唐的《十八岁，送我一个姑娘》，本以为高中对我来说就是在有序的学习计划中度过，没想到上天给了我一个惊喜，又跟我开了个玩笑。在十八岁到来的半年前，一个姑娘真的送到了我的眼前。 ​ ​ 她叫星竹。我叫她姑娘。 ​ 那时候天晴云暖，一切都是刚刚好的模样，我俩每天穿梭在学习、考试和偷偷见面聊上五分钟的生活中，为了和她发信息，我不惜躲到厕所信号最好的地方，大冬天在厕所里缩手缩脚地待一小时。用她的话来说，“空气要是有颜色，都是晚霞的绯红色。” ​ 在十七岁那一年，我把我能给的一切都给了她，我用尽自己能想到的方式关心她，即便她并不爱吃零食，我也坚持每天给她带一点，她为长痘烦恼，我听说吃苹果能调理痘痘，每天中午都会削好一个苹果拿给她，她每隔一个月左右会变得异常悲观，我都怯怯地安慰着她，怕她情绪失控，怕她哭泣……那时候谈恋爱都小心翼翼，我俩不在一个班，一个苹果要经过五六个人才能到她手里，表面会沾上一点点的灰色，她总是要洗一洗才敢吃，她想看的书，我想尽办法也会弄到，她不经意说喜欢的东西，我会想方设法地买过来……我很笨拙，但是我已经用上了我能想到的所有办法去爱她。 ​ 有一次我们在外面游玩，星竹突然变得垂头丧气，她常常会突然地沮丧，但我没想到这次她居然会偷偷地离开我们，当我们意识到她不见了的时候，已经快到傍晚。我下意识地自责起来，恨不得把牙咬碎，打她电话，关机，天毫不遮掩地下起大雨来，我可以想象到星竹在雨中哭泣的样子，我可以想象雨滴顺着她的发丝和指尖滴落的温度，我可以想象她手足无措的表情，我宁可让这雨千倍百倍地淋湿我，也不想让她的小世界有一点点湿度。 ​ 我找了她一个多小时，才发现她一个人躲在树下的长凳上发呆，她说不喜欢坐公共长椅，所以总是踩着纸巾蹲在上面，我看到她的时候，她脚下的纸巾已经破烂，她将自己的膝盖紧紧地抱着，眼神空洞地发呆，我缓缓走过去，把自己的外套张开悬在她的头顶，没有和她说话。她意识到我的到来之后，才有勇气大声地哭了起来，我就这样站在那里等她哭完，一句话也没有问。我知道在这世界上，关于星竹的事情我是理解不完的，我只希望每一次在她这样脆弱的时候，我都能陪在她身边，为她遮一点点的雨就好了。 ​ 那时候我以为，这样的关怀和照顾可以将她的心永远地锁在我身边。 ​ (待续)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[石乐志]]></title>
      <url>%2F2017%2F08%2F04%2F%E7%9F%B3%E4%B9%90%E5%BF%97%2F</url>
      <content type="text"><![CDATA[如果我再把 int main() 写成 int mian() 我就是猪！！！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[test]]></title>
      <url>%2F2017%2F07%2F03%2Ftest%2F</url>
      <content type="text"><![CDATA[waooo 真的只是做实验啦]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[New World]]></title>
      <url>%2F2017%2F06%2F24%2FMy-New-Post%2F</url>
      <content type="text"><![CDATA[Hello! This is my new blog.唔，在磊和然的帮助下，我终于搭成了第一个属于自己的博客。巧得很，当天晚上就发生了大新闻，所以拖到今天才打了一些字。还有很长的路要走，还有很多的坑要踩，不过每踩一次，都会学会一点东西吧。嗯，希望早点找到方向！！！]]></content>
    </entry>

    
  
  
</search>
